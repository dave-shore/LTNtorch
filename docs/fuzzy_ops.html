<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ltn.fuzzy_ops &mdash; LTNtorch 0.9 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="ltn.core" href="core.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> LTNtorch
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Notes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="grounding.html">Grounding in Logic Tensor Networks</a></li>
<li class="toctree-l1"><a class="reference internal" href="learningltn.html">Introduction to Learning in Logic Tensor Networks</a></li>
<li class="toctree-l1"><a class="reference internal" href="ltnobjects.html">LTN objects</a></li>
<li class="toctree-l1"><a class="reference internal" href="broadcasting.html">LTN broadcasting</a><ul>
<li class="toctree-l2"><a class="reference internal" href="broadcasting.html#ltn-predicate-case">LTN predicate case</a></li>
<li class="toctree-l2"><a class="reference internal" href="broadcasting.html#ltn-function-case">LTN function case</a></li>
<li class="toctree-l2"><a class="reference internal" href="broadcasting.html#ltn-connective-case">LTN connective case</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="quantification.html">Quantification in Logic Tensor Networks</a><ul>
<li class="toctree-l2"><a class="reference internal" href="quantification.html#base-quantification">Base quantification</a></li>
<li class="toctree-l2"><a class="reference internal" href="quantification.html#diagonal-quantification">Diagonal quantification</a></li>
<li class="toctree-l2"><a class="reference internal" href="quantification.html#guarded-quantification">Guarded quantification</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="stableconf.html">Stable Fuzzy Semantics</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Modules</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="core.html">ltn.core</a><ul>
<li class="toctree-l2"><a class="reference internal" href="core.html#members">Members</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">ltn.fuzzy_ops</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#members">Members</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">LTNtorch</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>ltn.fuzzy_ops</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/fuzzy_ops.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="ltn-fuzzy-ops">
<h1>ltn.fuzzy_ops<a class="headerlink" href="#ltn-fuzzy-ops" title="Permalink to this headline"></a></h1>
<section id="members">
<h2>Members<a class="headerlink" href="#members" title="Permalink to this headline"></a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#ltn.fuzzy_ops.ConnectiveOperator" title="ltn.fuzzy_ops.ConnectiveOperator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ltn.fuzzy_ops.ConnectiveOperator</span></code></a>()</p></td>
<td><p>Abstract class for connective operators.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ltn.fuzzy_ops.UnaryConnectiveOperator" title="ltn.fuzzy_ops.UnaryConnectiveOperator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ltn.fuzzy_ops.UnaryConnectiveOperator</span></code></a>()</p></td>
<td><p>Abstract class for unary connective operators.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ltn.fuzzy_ops.BinaryConnectiveOperator" title="ltn.fuzzy_ops.BinaryConnectiveOperator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ltn.fuzzy_ops.BinaryConnectiveOperator</span></code></a>()</p></td>
<td><p>Abstract class for binary connective operators.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ltn.fuzzy_ops.NotStandard" title="ltn.fuzzy_ops.NotStandard"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ltn.fuzzy_ops.NotStandard</span></code></a>()</p></td>
<td><p>Standard fuzzy negation operator.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ltn.fuzzy_ops.NotGodel" title="ltn.fuzzy_ops.NotGodel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ltn.fuzzy_ops.NotGodel</span></code></a>()</p></td>
<td><p>Godel fuzzy negation operator.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ltn.fuzzy_ops.AndMin" title="ltn.fuzzy_ops.AndMin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ltn.fuzzy_ops.AndMin</span></code></a>()</p></td>
<td><p>Godel fuzzy conjunction operator (min operator).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ltn.fuzzy_ops.AndProd" title="ltn.fuzzy_ops.AndProd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ltn.fuzzy_ops.AndProd</span></code></a>([stable])</p></td>
<td><p>Goguen fuzzy conjunction operator (product operator).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ltn.fuzzy_ops.AndLuk" title="ltn.fuzzy_ops.AndLuk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ltn.fuzzy_ops.AndLuk</span></code></a>()</p></td>
<td><p>Lukasiewicz fuzzy conjunction operator.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ltn.fuzzy_ops.OrMax" title="ltn.fuzzy_ops.OrMax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ltn.fuzzy_ops.OrMax</span></code></a>()</p></td>
<td><p>Godel fuzzy disjunction operator (max operator).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ltn.fuzzy_ops.OrProbSum" title="ltn.fuzzy_ops.OrProbSum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ltn.fuzzy_ops.OrProbSum</span></code></a>([stable])</p></td>
<td><p>Goguen fuzzy disjunction operator (probabilistic sum).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ltn.fuzzy_ops.OrLuk" title="ltn.fuzzy_ops.OrLuk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ltn.fuzzy_ops.OrLuk</span></code></a>()</p></td>
<td><p>Lukasiewicz fuzzy disjunction operator.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ltn.fuzzy_ops.ImpliesKleeneDienes" title="ltn.fuzzy_ops.ImpliesKleeneDienes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ltn.fuzzy_ops.ImpliesKleeneDienes</span></code></a>()</p></td>
<td><p>Kleene Dienes fuzzy implication operator.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ltn.fuzzy_ops.ImpliesGodel" title="ltn.fuzzy_ops.ImpliesGodel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ltn.fuzzy_ops.ImpliesGodel</span></code></a>()</p></td>
<td><p>Godel fuzzy implication operand.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ltn.fuzzy_ops.ImpliesReichenbach" title="ltn.fuzzy_ops.ImpliesReichenbach"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ltn.fuzzy_ops.ImpliesReichenbach</span></code></a>([stable])</p></td>
<td><p>Reichenbach fuzzy implication operator.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ltn.fuzzy_ops.ImpliesGoguen" title="ltn.fuzzy_ops.ImpliesGoguen"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ltn.fuzzy_ops.ImpliesGoguen</span></code></a>([stable])</p></td>
<td><p>Goguen fuzzy implication operator.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ltn.fuzzy_ops.Equiv" title="ltn.fuzzy_ops.Equiv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ltn.fuzzy_ops.Equiv</span></code></a>(and_op, implies_op)</p></td>
<td><p>Equivalence (<span class="math notranslate nohighlight">\(\leftrightarrow\)</span>) fuzzy operator.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ltn.fuzzy_ops.AggregationOperator" title="ltn.fuzzy_ops.AggregationOperator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ltn.fuzzy_ops.AggregationOperator</span></code></a>()</p></td>
<td><p>Abstract class for aggregation operators.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ltn.fuzzy_ops.AggregMin" title="ltn.fuzzy_ops.AggregMin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ltn.fuzzy_ops.AggregMin</span></code></a>()</p></td>
<td><p>Min fuzzy aggregation operator.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ltn.fuzzy_ops.AggregMean" title="ltn.fuzzy_ops.AggregMean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ltn.fuzzy_ops.AggregMean</span></code></a>()</p></td>
<td><p>Mean fuzzy aggregation operator.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ltn.fuzzy_ops.AggregPMean" title="ltn.fuzzy_ops.AggregPMean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ltn.fuzzy_ops.AggregPMean</span></code></a>([p, stable])</p></td>
<td><p><cite>pMean</cite> fuzzy aggregation operator.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ltn.fuzzy_ops.AggregPMeanError" title="ltn.fuzzy_ops.AggregPMeanError"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ltn.fuzzy_ops.AggregPMeanError</span></code></a>([p, stable])</p></td>
<td><p><cite>pMeanError</cite> fuzzy aggregation operator.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ltn.fuzzy_ops.SatAgg" title="ltn.fuzzy_ops.SatAgg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ltn.fuzzy_ops.SatAgg</span></code></a>([agg_op])</p></td>
<td><p><cite>SatAgg</cite> aggregation operator.</p></td>
</tr>
</tbody>
</table>
<span class="target" id="module-ltn.fuzzy_ops"></span><p id="fuzzyop">The <cite>ltn.fuzzy_ops</cite> module contains the PyTorch implementation of some common fuzzy logic operators and aggregators.
Refer to the <a class="reference external" href="https://arxiv.org/abs/2012.13635">LTN paper</a> for a detailed description of these operators
(see the Appendix).</p>
<p>All the operators included in this module support the traditional NumPy/PyTorch broadcasting.</p>
<p>The operators have been designed to be used with <a class="reference internal" href="core.html#ltn.core.Connective" title="ltn.core.Connective"><code class="xref py py-class docutils literal notranslate"><span class="pre">ltn.core.Connective</span></code></a> or <a class="reference internal" href="core.html#ltn.core.Quantifier" title="ltn.core.Quantifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">ltn.core.Quantifier</span></code></a>.</p>
<dl class="py class">
<dt class="sig sig-object py" id="ltn.fuzzy_ops.ConnectiveOperator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ltn.fuzzy_ops.</span></span><span class="sig-name descname"><span class="pre">ConnectiveOperator</span></span><a class="headerlink" href="#ltn.fuzzy_ops.ConnectiveOperator" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Abstract class for connective operators.</p>
<p>Every connective operator implemented in LTNtorch must inherit from this class and implements
the <cite>__call__()</cite> method.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#NotImplementedError" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a></dt><dd><p>Raised when <cite>__call__()</cite> is not implemented in the sub-class.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ltn.fuzzy_ops.UnaryConnectiveOperator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ltn.fuzzy_ops.</span></span><span class="sig-name descname"><span class="pre">UnaryConnectiveOperator</span></span><a class="headerlink" href="#ltn.fuzzy_ops.UnaryConnectiveOperator" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#ltn.fuzzy_ops.ConnectiveOperator" title="ltn.fuzzy_ops.ConnectiveOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">ltn.fuzzy_ops.ConnectiveOperator</span></code></a></p>
<p>Abstract class for unary connective operators.</p>
<p>Every unary connective operator implemented in LTNtorch must inherit from this class and
implement the <cite>__call__()</cite> method.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#NotImplementedError" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a></dt><dd><p>Raised when <cite>__call__()</cite> is not implemented in the sub-class.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ltn.fuzzy_ops.BinaryConnectiveOperator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ltn.fuzzy_ops.</span></span><span class="sig-name descname"><span class="pre">BinaryConnectiveOperator</span></span><a class="headerlink" href="#ltn.fuzzy_ops.BinaryConnectiveOperator" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#ltn.fuzzy_ops.ConnectiveOperator" title="ltn.fuzzy_ops.ConnectiveOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">ltn.fuzzy_ops.ConnectiveOperator</span></code></a></p>
<p>Abstract class for binary connective operators.</p>
<p>Every binary connective operator implemented in LTNtorch must inherit from this class
and implement the <cite>__call__()</cite> method.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#NotImplementedError" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a></dt><dd><p>Raised when <cite>__call__()</cite> is not implemented in the sub-class.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ltn.fuzzy_ops.NotStandard">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ltn.fuzzy_ops.</span></span><span class="sig-name descname"><span class="pre">NotStandard</span></span><a class="headerlink" href="#ltn.fuzzy_ops.NotStandard" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#ltn.fuzzy_ops.UnaryConnectiveOperator" title="ltn.fuzzy_ops.UnaryConnectiveOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">ltn.fuzzy_ops.UnaryConnectiveOperator</span></code></a></p>
<p>Standard fuzzy negation operator.</p>
<p><span class="math notranslate nohighlight">\(\lnot_{standard}(x) = 1 - x\)</span></p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ltn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Not</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Connective</span><span class="p">(</span><span class="n">ltn</span><span class="o">.</span><span class="n">fuzzy_ops</span><span class="o">.</span><span class="n">NotStandard</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Not</span><span class="p">)</span>
<span class="go">Connective(connective_op=NotStandard())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Predicate</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Sigmoid</span><span class="p">()(</span>
<span class="gp">... </span>                                    <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">... </span>                                 <span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mf">0.56</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.9</span><span class="p">]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">tensor([0.6365, 0.7109])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Not</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">tensor([0.3635, 0.2891])</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="ltn.fuzzy_ops.NotStandard.__call__">
<span class="sig-name descname"><span class="pre">__call__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ltn.fuzzy_ops.NotStandard.__call__" title="Permalink to this definition"></a></dt>
<dd><p>It applies the standard fuzzy negation operator to the given operand.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>x</strong><span class="classifier"><a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a></span></dt><dd><p>Operand on which the operator has to be applied.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a></dt><dd><p>The standard fuzzy negation of the given operand.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ltn.fuzzy_ops.NotGodel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ltn.fuzzy_ops.</span></span><span class="sig-name descname"><span class="pre">NotGodel</span></span><a class="headerlink" href="#ltn.fuzzy_ops.NotGodel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#ltn.fuzzy_ops.UnaryConnectiveOperator" title="ltn.fuzzy_ops.UnaryConnectiveOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">ltn.fuzzy_ops.UnaryConnectiveOperator</span></code></a></p>
<p>Godel fuzzy negation operator.</p>
<p><span class="math notranslate nohighlight">\(\lnot_{Godel}(x) = \left\{\begin{array}{ c l }1 &amp; \quad \textrm{if } x = 0 \\ 0 &amp; \quad \textrm{otherwise} \end{array} \right.\)</span></p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ltn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Not</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Connective</span><span class="p">(</span><span class="n">ltn</span><span class="o">.</span><span class="n">fuzzy_ops</span><span class="o">.</span><span class="n">NotGodel</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Not</span><span class="p">)</span>
<span class="go">Connective(connective_op=NotGodel())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Predicate</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Sigmoid</span><span class="p">()(</span>
<span class="gp">... </span>                                    <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">... </span>                                 <span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mf">0.56</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.9</span><span class="p">]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">tensor([0.6365, 0.7109])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Not</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">tensor([0., 0.])</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="ltn.fuzzy_ops.NotGodel.__call__">
<span class="sig-name descname"><span class="pre">__call__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ltn.fuzzy_ops.NotGodel.__call__" title="Permalink to this definition"></a></dt>
<dd><p>It applies the Godel fuzzy negation operator to the given operand.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>x</strong><span class="classifier"><a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a></span></dt><dd><p>Operand on which the operator has to be applied.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a></dt><dd><p>The Godel fuzzy negation of the given operand.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ltn.fuzzy_ops.AndMin">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ltn.fuzzy_ops.</span></span><span class="sig-name descname"><span class="pre">AndMin</span></span><a class="headerlink" href="#ltn.fuzzy_ops.AndMin" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#ltn.fuzzy_ops.BinaryConnectiveOperator" title="ltn.fuzzy_ops.BinaryConnectiveOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">ltn.fuzzy_ops.BinaryConnectiveOperator</span></code></a></p>
<p>Godel fuzzy conjunction operator (min operator).</p>
<p><span class="math notranslate nohighlight">\(\land_{Godel}(x, y) = \operatorname{min}(x, y)\)</span></p>
<p class="rubric">Examples</p>
<p>Note that:</p>
<ul class="simple">
<li><p>variable <cite>x</cite> has two individuals;</p></li>
<li><p>variable <cite>y</cite> has three individuals;</p></li>
<li><p>the shape of the result of the conjunction is <cite>(2, 3)</cite> due to the <a class="reference internal" href="broadcasting.html#broadcasting"><span class="std std-ref">LTN broadcasting</span></a>. The first dimension is dedicated two variable <cite>x</cite>, while the second dimension to variable <cite>y</cite>;</p></li>
<li><p>at index <cite>(0, 0)</cite> there is the evaluation of the formula on first individual of <cite>x</cite> and first individual of <cite>y</cite>, at index <cite>(0, 1)</cite> there is the evaluation of the formula on first individual of <cite>x</cite> and second individual of <cite>y</cite>, and so forth.</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ltn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">And</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Connective</span><span class="p">(</span><span class="n">ltn</span><span class="o">.</span><span class="n">fuzzy_ops</span><span class="o">.</span><span class="n">AndMin</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">And</span><span class="p">)</span>
<span class="go">Connective(connective_op=AndMin())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Predicate</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Sigmoid</span><span class="p">()(</span>
<span class="gp">... </span>                                    <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">... </span>                                 <span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mf">0.56</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.9</span><span class="p">]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mf">0.7</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">tensor([0.6365, 0.7109])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">tensor([0.6682, 0.5498, 0.5250])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">And</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">p</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">tensor([[0.6365, 0.5498, 0.5250],</span>
<span class="go">        [0.6682, 0.5498, 0.5250]])</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="ltn.fuzzy_ops.AndMin.__call__">
<span class="sig-name descname"><span class="pre">__call__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ltn.fuzzy_ops.AndMin.__call__" title="Permalink to this definition"></a></dt>
<dd><p>It applies the Godel fuzzy conjunction operator to the given operands.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>x</strong><span class="classifier"><a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a></span></dt><dd><p>First operand on which the operator has to be applied.</p>
</dd>
<dt><strong>y</strong><span class="classifier"><a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a></span></dt><dd><p>Second operand on which the operator has to be applied.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a></dt><dd><p>The Godel fuzzy conjunction of the two operands.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ltn.fuzzy_ops.AndProd">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ltn.fuzzy_ops.</span></span><span class="sig-name descname"><span class="pre">AndProd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ltn.fuzzy_ops.AndProd" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#ltn.fuzzy_ops.BinaryConnectiveOperator" title="ltn.fuzzy_ops.BinaryConnectiveOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">ltn.fuzzy_ops.BinaryConnectiveOperator</span></code></a></p>
<p>Goguen fuzzy conjunction operator (product operator).</p>
<p><span class="math notranslate nohighlight">\(\land_{Goguen}(x, y) = xy\)</span></p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>stable</strong><span class="classifier"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code></a>, default=True</span></dt><dd><p>Flag indicating whether to use the <a class="reference external" href="https://docs.python.org/3/c-api/stable.html#stable" title="(in Python v3.12)"><span class="xref std std-ref">stable version</span></a> of the operator or not.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The Gougen fuzzy conjunction could have vanishing gradients if not used in its <a class="reference external" href="https://docs.python.org/3/c-api/stable.html#stable" title="(in Python v3.12)"><span class="xref std std-ref">stable</span></a> version.</p>
<p class="rubric">Examples</p>
<p>Note that:</p>
<ul class="simple">
<li><p>variable <cite>x</cite> has two individuals;</p></li>
<li><p>variable <cite>y</cite> has three individuals;</p></li>
<li><p>the shape of the result of the conjunction is <cite>(2, 3)</cite> due to the <a class="reference internal" href="broadcasting.html#broadcasting"><span class="std std-ref">LTN broadcasting</span></a>. The first dimension is dedicated two variable <cite>x</cite>, while the second dimension to variable <cite>y</cite>;</p></li>
<li><p>at index <cite>(0, 0)</cite> there is the evaluation of the formula on first individual of <cite>x</cite> and first individual of <cite>y</cite>, at index <cite>(0, 1)</cite> there is the evaluation of the formula on first individual of <cite>x</cite> and second individual of <cite>y</cite>, and so forth.</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ltn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">And</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Connective</span><span class="p">(</span><span class="n">ltn</span><span class="o">.</span><span class="n">fuzzy_ops</span><span class="o">.</span><span class="n">AndProd</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">And</span><span class="p">)</span>
<span class="go">Connective(connective_op=AndProd(stable=True))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Predicate</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Sigmoid</span><span class="p">()(</span>
<span class="gp">... </span>                                    <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">... </span>                                 <span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mf">0.56</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.9</span><span class="p">]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mf">0.7</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">tensor([0.6365, 0.7109])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">tensor([0.6682, 0.5498, 0.5250])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">And</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">p</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">tensor([[0.4253, 0.3500, 0.3342],</span>
<span class="go">        [0.4751, 0.3910, 0.3733]])</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="ltn.fuzzy_ops.AndProd.__call__">
<span class="sig-name descname"><span class="pre">__call__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ltn.fuzzy_ops.AndProd.__call__" title="Permalink to this definition"></a></dt>
<dd><p>It applies the Goguen fuzzy conjunction operator to the given operands.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>x</strong><span class="classifier"><a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a></span></dt><dd><p>First operand on which the operator has to be applied.</p>
</dd>
<dt><strong>y</strong><span class="classifier"><a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a></span></dt><dd><p>Second operand on which the operator has to be applied.</p>
</dd>
<dt><strong>stable</strong><span class="classifier"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code></a>, default=None</span></dt><dd><p>Flag indicating whether to use the <a class="reference external" href="https://docs.python.org/3/c-api/stable.html#stable" title="(in Python v3.12)"><span class="xref std std-ref">stable version</span></a> of the operator or not.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a></dt><dd><p>The Goguen fuzzy conjunction of the two operands.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="field-list">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl>
<dt><strong>stable</strong><span class="classifier"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code></a></span></dt><dd><p>See <cite>stable</cite> parameter.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ltn.fuzzy_ops.AndLuk">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ltn.fuzzy_ops.</span></span><span class="sig-name descname"><span class="pre">AndLuk</span></span><a class="headerlink" href="#ltn.fuzzy_ops.AndLuk" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#ltn.fuzzy_ops.BinaryConnectiveOperator" title="ltn.fuzzy_ops.BinaryConnectiveOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">ltn.fuzzy_ops.BinaryConnectiveOperator</span></code></a></p>
<p>Lukasiewicz fuzzy conjunction operator.</p>
<p><span class="math notranslate nohighlight">\(\land_{Lukasiewicz}(x, y) = \operatorname{max}(x + y - 1, 0)\)</span></p>
<p class="rubric">Examples</p>
<p>Note that:</p>
<ul class="simple">
<li><p>variable <cite>x</cite> has two individuals;</p></li>
<li><p>variable <cite>y</cite> has three individuals;</p></li>
<li><p>the shape of the result of the conjunction is <cite>(2, 3)</cite> due to the <a class="reference internal" href="broadcasting.html#broadcasting"><span class="std std-ref">LTN broadcasting</span></a>. The first dimension is dedicated two variable <cite>x</cite>, while the second dimension to variable <cite>y</cite>;</p></li>
<li><p>at index <cite>(0, 0)</cite> there is the evaluation of the formula on first individual of <cite>x</cite> and first individual of <cite>y</cite>, at index <cite>(0, 1)</cite> there is the evaluation of the formula on first individual of <cite>x</cite> and second individual of <cite>y</cite>, and so forth.</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ltn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">And</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Connective</span><span class="p">(</span><span class="n">ltn</span><span class="o">.</span><span class="n">fuzzy_ops</span><span class="o">.</span><span class="n">AndLuk</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">And</span><span class="p">)</span>
<span class="go">Connective(connective_op=AndLuk())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Predicate</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Sigmoid</span><span class="p">()(</span>
<span class="gp">... </span>                                    <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">... </span>                                 <span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mf">0.56</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.9</span><span class="p">]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mf">0.7</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">tensor([0.6365, 0.7109])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">tensor([0.6682, 0.5498, 0.5250])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">And</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">p</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">tensor([[0.3046, 0.1863, 0.1614],</span>
<span class="go">        [0.3791, 0.2608, 0.2359]])</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="ltn.fuzzy_ops.AndLuk.__call__">
<span class="sig-name descname"><span class="pre">__call__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ltn.fuzzy_ops.AndLuk.__call__" title="Permalink to this definition"></a></dt>
<dd><p>It applies the Lukasiewicz fuzzy conjunction operator to the given operands.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>x</strong><span class="classifier"><a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a></span></dt><dd><p>First operand on which the operator has to be applied.</p>
</dd>
<dt><strong>y</strong><span class="classifier"><a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a></span></dt><dd><p>Second operand on which the operator has to be applied.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a></dt><dd><p>The Lukasiewicz fuzzy conjunction of the two operands.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ltn.fuzzy_ops.OrMax">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ltn.fuzzy_ops.</span></span><span class="sig-name descname"><span class="pre">OrMax</span></span><a class="headerlink" href="#ltn.fuzzy_ops.OrMax" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#ltn.fuzzy_ops.BinaryConnectiveOperator" title="ltn.fuzzy_ops.BinaryConnectiveOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">ltn.fuzzy_ops.BinaryConnectiveOperator</span></code></a></p>
<p>Godel fuzzy disjunction operator (max operator).</p>
<p><span class="math notranslate nohighlight">\(\lor_{Godel}(x, y) = \operatorname{max}(x, y)\)</span></p>
<p class="rubric">Examples</p>
<p>Note that:</p>
<ul class="simple">
<li><p>variable <cite>x</cite> has two individuals;</p></li>
<li><p>variable <cite>y</cite> has three individuals;</p></li>
<li><p>the shape of the result of the conjunction is <cite>(2, 3)</cite> due to the <a class="reference internal" href="broadcasting.html#broadcasting"><span class="std std-ref">LTN broadcasting</span></a>. The first dimension is dedicated two variable <cite>x</cite>, while the second dimension to variable <cite>y</cite>;</p></li>
<li><p>at index <cite>(0, 0)</cite> there is the evaluation of the formula on first individual of <cite>x</cite> and first individual of <cite>y</cite>, at index <cite>(0, 1)</cite> there is the evaluation of the formula on first individual of <cite>x</cite> and second individual of <cite>y</cite>, and so forth.</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ltn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Or</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Connective</span><span class="p">(</span><span class="n">ltn</span><span class="o">.</span><span class="n">fuzzy_ops</span><span class="o">.</span><span class="n">OrMax</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Or</span><span class="p">)</span>
<span class="go">Connective(connective_op=OrMax())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Predicate</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Sigmoid</span><span class="p">()(</span>
<span class="gp">... </span>                                    <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">... </span>                                 <span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mf">0.56</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.9</span><span class="p">]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mf">0.7</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">tensor([0.6365, 0.7109])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">tensor([0.6682, 0.5498, 0.5250])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Or</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">p</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">tensor([[0.6682, 0.6365, 0.6365],</span>
<span class="go">        [0.7109, 0.7109, 0.7109]])</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="ltn.fuzzy_ops.OrMax.__call__">
<span class="sig-name descname"><span class="pre">__call__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ltn.fuzzy_ops.OrMax.__call__" title="Permalink to this definition"></a></dt>
<dd><p>It applies the Godel fuzzy disjunction operator to the given operands.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>x</strong><span class="classifier"><a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a></span></dt><dd><p>First operand on which the operator has to be applied.</p>
</dd>
<dt><strong>y</strong><span class="classifier"><a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a></span></dt><dd><p>Second operand on which the operator has to be applied.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a></dt><dd><p>The Godel fuzzy disjunction of the two operands.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ltn.fuzzy_ops.OrProbSum">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ltn.fuzzy_ops.</span></span><span class="sig-name descname"><span class="pre">OrProbSum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ltn.fuzzy_ops.OrProbSum" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#ltn.fuzzy_ops.BinaryConnectiveOperator" title="ltn.fuzzy_ops.BinaryConnectiveOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">ltn.fuzzy_ops.BinaryConnectiveOperator</span></code></a></p>
<p>Goguen fuzzy disjunction operator (probabilistic sum).</p>
<p><span class="math notranslate nohighlight">\(\lor_{Goguen}(x, y) = x + y - xy\)</span></p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>stable</strong><span class="classifier"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code></a>, default=True</span></dt><dd><p>Flag indicating whether to use the <a class="reference external" href="https://docs.python.org/3/c-api/stable.html#stable" title="(in Python v3.12)"><span class="xref std std-ref">stable version</span></a> of the operator or not.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The Gougen fuzzy disjunction could have vanishing gradients if not used in its <a class="reference external" href="https://docs.python.org/3/c-api/stable.html#stable" title="(in Python v3.12)"><span class="xref std std-ref">stable</span></a> version.</p>
<p class="rubric">Examples</p>
<p>Note that:</p>
<ul class="simple">
<li><p>variable <cite>x</cite> has two individuals;</p></li>
<li><p>variable <cite>y</cite> has three individuals;</p></li>
<li><p>the shape of the result of the conjunction is <cite>(2, 3)</cite> due to the <a class="reference internal" href="broadcasting.html#broadcasting"><span class="std std-ref">LTN broadcasting</span></a>. The first dimension is dedicated two variable <cite>x</cite>, while the second dimension to variable <cite>y</cite>;</p></li>
<li><p>at index <cite>(0, 0)</cite> there is the evaluation of the formula on first individual of <cite>x</cite> and first individual of <cite>y</cite>, at index <cite>(0, 1)</cite> there is the evaluation of the formula on first individual of <cite>x</cite> and second individual of <cite>y</cite>, and so forth.</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ltn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Or</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Connective</span><span class="p">(</span><span class="n">ltn</span><span class="o">.</span><span class="n">fuzzy_ops</span><span class="o">.</span><span class="n">OrProbSum</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Or</span><span class="p">)</span>
<span class="go">Connective(connective_op=OrProbSum(stable=True))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Predicate</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Sigmoid</span><span class="p">()(</span>
<span class="gp">... </span>                                    <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">... </span>                                 <span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mf">0.56</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.9</span><span class="p">]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mf">0.7</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">tensor([0.6365, 0.7109])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">tensor([0.6682, 0.5498, 0.5250])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Or</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">p</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">tensor([[0.8793, 0.8363, 0.8273],</span>
<span class="go">        [0.9040, 0.8698, 0.8626]])</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="ltn.fuzzy_ops.OrProbSum.__call__">
<span class="sig-name descname"><span class="pre">__call__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ltn.fuzzy_ops.OrProbSum.__call__" title="Permalink to this definition"></a></dt>
<dd><p>It applies the Goguen fuzzy disjunction operator to the given operands.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>x</strong><span class="classifier"><a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a></span></dt><dd><p>First operand on which the operator has to be applied.</p>
</dd>
<dt><strong>y</strong><span class="classifier"><a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a></span></dt><dd><p>Second operand on which the operator has to be applied.</p>
</dd>
<dt><strong>stable</strong><span class="classifier"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code></a>, default=None</span></dt><dd><p>Flag indicating whether to use the <a class="reference external" href="https://docs.python.org/3/c-api/stable.html#stable" title="(in Python v3.12)"><span class="xref std std-ref">stable version</span></a> of the operator or not.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a></dt><dd><p>The Goguen fuzzy disjunction of the two operands.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="field-list">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl>
<dt><strong>stable</strong><span class="classifier"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code></a></span></dt><dd><p>See <cite>stable</cite> parameter.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ltn.fuzzy_ops.OrLuk">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ltn.fuzzy_ops.</span></span><span class="sig-name descname"><span class="pre">OrLuk</span></span><a class="headerlink" href="#ltn.fuzzy_ops.OrLuk" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#ltn.fuzzy_ops.BinaryConnectiveOperator" title="ltn.fuzzy_ops.BinaryConnectiveOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">ltn.fuzzy_ops.BinaryConnectiveOperator</span></code></a></p>
<p>Lukasiewicz fuzzy disjunction operator.</p>
<p><span class="math notranslate nohighlight">\(\lor_{Lukasiewicz}(x, y) = \operatorname{min}(x + y, 1)\)</span></p>
<p class="rubric">Examples</p>
<p>Note that:</p>
<ul class="simple">
<li><p>variable <cite>x</cite> has two individuals;</p></li>
<li><p>variable <cite>y</cite> has three individuals;</p></li>
<li><p>the shape of the result of the conjunction is <cite>(2, 3)</cite> due to the <a class="reference internal" href="broadcasting.html#broadcasting"><span class="std std-ref">LTN broadcasting</span></a>. The first dimension is dedicated two variable <cite>x</cite>, while the second dimension to variable <cite>y</cite>;</p></li>
<li><p>at index <cite>(0, 0)</cite> there is the evaluation of the formula on first individual of <cite>x</cite> and first individual of <cite>y</cite>, at index <cite>(0, 1)</cite> there is the evaluation of the formula on first individual of <cite>x</cite> and second individual of <cite>y</cite>, and so forth.</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ltn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Or</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Connective</span><span class="p">(</span><span class="n">ltn</span><span class="o">.</span><span class="n">fuzzy_ops</span><span class="o">.</span><span class="n">OrLuk</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Or</span><span class="p">)</span>
<span class="go">Connective(connective_op=OrLuk())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Predicate</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Sigmoid</span><span class="p">()(</span>
<span class="gp">... </span>                                    <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">... </span>                                 <span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mf">0.56</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.9</span><span class="p">]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mf">0.7</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">tensor([0.6365, 0.7109])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">tensor([0.6682, 0.5498, 0.5250])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Or</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">p</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">tensor([[1., 1., 1.],</span>
<span class="go">        [1., 1., 1.]])</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="ltn.fuzzy_ops.OrLuk.__call__">
<span class="sig-name descname"><span class="pre">__call__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ltn.fuzzy_ops.OrLuk.__call__" title="Permalink to this definition"></a></dt>
<dd><p>It applies the Lukasiewicz fuzzy disjunction operator to the given operands.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>x</strong><span class="classifier"><a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a></span></dt><dd><p>First operand on which the operator has to be applied.</p>
</dd>
<dt><strong>y</strong><span class="classifier"><a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a></span></dt><dd><p>Second operand on which the operator has to be applied.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a></dt><dd><p>The Lukasiewicz fuzzy disjunction of the two operands.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ltn.fuzzy_ops.ImpliesKleeneDienes">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ltn.fuzzy_ops.</span></span><span class="sig-name descname"><span class="pre">ImpliesKleeneDienes</span></span><a class="headerlink" href="#ltn.fuzzy_ops.ImpliesKleeneDienes" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#ltn.fuzzy_ops.BinaryConnectiveOperator" title="ltn.fuzzy_ops.BinaryConnectiveOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">ltn.fuzzy_ops.BinaryConnectiveOperator</span></code></a></p>
<p>Kleene Dienes fuzzy implication operator.</p>
<p><span class="math notranslate nohighlight">\(\rightarrow_{KleeneDienes}(x, y) = \operatorname{max}(1 - x, y)\)</span></p>
<p class="rubric">Examples</p>
<p>Note that:</p>
<ul class="simple">
<li><p>variable <cite>x</cite> has two individuals;</p></li>
<li><p>variable <cite>y</cite> has three individuals;</p></li>
<li><p>the shape of the result of the conjunction is <cite>(2, 3)</cite> due to the <a class="reference internal" href="broadcasting.html#broadcasting"><span class="std std-ref">LTN broadcasting</span></a>. The first dimension is dedicated two variable <cite>x</cite>, while the second dimension to variable <cite>y</cite>;</p></li>
<li><p>at index <cite>(0, 0)</cite> there is the evaluation of the formula on first individual of <cite>x</cite> and first individual of <cite>y</cite>, at index <cite>(0, 1)</cite> there is the evaluation of the formula on first individual of <cite>x</cite> and second individual of <cite>y</cite>, and so forth.</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ltn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Implies</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Connective</span><span class="p">(</span><span class="n">ltn</span><span class="o">.</span><span class="n">fuzzy_ops</span><span class="o">.</span><span class="n">ImpliesKleeneDienes</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Implies</span><span class="p">)</span>
<span class="go">Connective(connective_op=ImpliesKleeneDienes())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Predicate</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Sigmoid</span><span class="p">()(</span>
<span class="gp">... </span>                                    <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">... </span>                                 <span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mf">0.56</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.9</span><span class="p">]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mf">0.7</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">tensor([0.6365, 0.7109])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">tensor([0.6682, 0.5498, 0.5250])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Implies</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">p</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">tensor([[0.6682, 0.5498, 0.5250],</span>
<span class="go">        [0.6682, 0.5498, 0.5250]])</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="ltn.fuzzy_ops.ImpliesKleeneDienes.__call__">
<span class="sig-name descname"><span class="pre">__call__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ltn.fuzzy_ops.ImpliesKleeneDienes.__call__" title="Permalink to this definition"></a></dt>
<dd><p>It applies the Kleene Dienes fuzzy implication operator to the given operands.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>x</strong><span class="classifier"><a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a></span></dt><dd><p>First operand on which the operator has to be applied.</p>
</dd>
<dt><strong>y</strong><span class="classifier"><a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a></span></dt><dd><p>Second operand on which the operator has to be applied.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a></dt><dd><p>The Kleene Dienes fuzzy implication of the two operands.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ltn.fuzzy_ops.ImpliesGodel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ltn.fuzzy_ops.</span></span><span class="sig-name descname"><span class="pre">ImpliesGodel</span></span><a class="headerlink" href="#ltn.fuzzy_ops.ImpliesGodel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#ltn.fuzzy_ops.BinaryConnectiveOperator" title="ltn.fuzzy_ops.BinaryConnectiveOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">ltn.fuzzy_ops.BinaryConnectiveOperator</span></code></a></p>
<p>Godel fuzzy implication operand.</p>
<p><span class="math notranslate nohighlight">\(\rightarrow_{Godel}(x, y) = \left\{\begin{array}{ c l }1 &amp; \quad \textrm{if } x \le y \\ y &amp; \quad \textrm{otherwise} \end{array} \right.\)</span></p>
<p class="rubric">Examples</p>
<p>Note that:</p>
<ul class="simple">
<li><p>variable <cite>x</cite> has two individuals;</p></li>
<li><p>variable <cite>y</cite> has three individuals;</p></li>
<li><p>the shape of the result of the conjunction is <cite>(2, 3)</cite> due to the <a class="reference internal" href="broadcasting.html#broadcasting"><span class="std std-ref">LTN broadcasting</span></a>. The first dimension is dedicated two variable <cite>x</cite>, while the second dimension to variable <cite>y</cite>;</p></li>
<li><p>at index <cite>(0, 0)</cite> there is the evaluation of the formula on first individual of <cite>x</cite> and first individual of <cite>y</cite>, at index <cite>(0, 1)</cite> there is the evaluation of the formula on first individual of <cite>x</cite> and second individual of <cite>y</cite>, and so forth.</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ltn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Implies</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Connective</span><span class="p">(</span><span class="n">ltn</span><span class="o">.</span><span class="n">fuzzy_ops</span><span class="o">.</span><span class="n">ImpliesGodel</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Implies</span><span class="p">)</span>
<span class="go">Connective(connective_op=ImpliesGodel())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Predicate</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Sigmoid</span><span class="p">()(</span>
<span class="gp">... </span>                                    <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">... </span>                                 <span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mf">0.56</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.9</span><span class="p">]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mf">0.7</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">tensor([0.6365, 0.7109])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">tensor([0.6682, 0.5498, 0.5250])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Implies</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">p</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">tensor([[1.0000, 0.5498, 0.5250],</span>
<span class="go">        [0.6682, 0.5498, 0.5250]])</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="ltn.fuzzy_ops.ImpliesGodel.__call__">
<span class="sig-name descname"><span class="pre">__call__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ltn.fuzzy_ops.ImpliesGodel.__call__" title="Permalink to this definition"></a></dt>
<dd><p>It applies the Godel fuzzy implication operator to the given operands.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>x</strong><span class="classifier"><a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a></span></dt><dd><p>First operand on which the operator has to be applied.</p>
</dd>
<dt><strong>y</strong><span class="classifier"><a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a></span></dt><dd><p>Second operand on which the operator has to be applied.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a></dt><dd><p>The Godel fuzzy implication of the two operands.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ltn.fuzzy_ops.ImpliesReichenbach">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ltn.fuzzy_ops.</span></span><span class="sig-name descname"><span class="pre">ImpliesReichenbach</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ltn.fuzzy_ops.ImpliesReichenbach" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#ltn.fuzzy_ops.BinaryConnectiveOperator" title="ltn.fuzzy_ops.BinaryConnectiveOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">ltn.fuzzy_ops.BinaryConnectiveOperator</span></code></a></p>
<p>Reichenbach fuzzy implication operator.</p>
<p><span class="math notranslate nohighlight">\(\rightarrow_{Reichenbach}(x, y) = 1 - x + xy\)</span></p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>stable</strong><span class="classifier"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code></a>, default=True</span></dt><dd><p>Flag indicating whether to use the <a class="reference external" href="https://docs.python.org/3/c-api/stable.html#stable" title="(in Python v3.12)"><span class="xref std std-ref">stable version</span></a> of the operator or not.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The Reichenbach fuzzy implication could have vanishing gradients if not used in its <a class="reference external" href="https://docs.python.org/3/c-api/stable.html#stable" title="(in Python v3.12)"><span class="xref std std-ref">stable</span></a> version.</p>
<p class="rubric">Examples</p>
<p>Note that:</p>
<ul class="simple">
<li><p>variable <cite>x</cite> has two individuals;</p></li>
<li><p>variable <cite>y</cite> has three individuals;</p></li>
<li><p>the shape of the result of the conjunction is <cite>(2, 3)</cite> due to the <a class="reference internal" href="broadcasting.html#broadcasting"><span class="std std-ref">LTN broadcasting</span></a>. The first dimension is dedicated two variable <cite>x</cite>, while the second dimension to variable <cite>y</cite>;</p></li>
<li><p>at index <cite>(0, 0)</cite> there is the evaluation of the formula on first individual of <cite>x</cite> and first individual of <cite>y</cite>, at index <cite>(0, 1)</cite> there is the evaluation of the formula on first individual of <cite>x</cite> and second individual of <cite>y</cite>, and so forth.</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ltn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Implies</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Connective</span><span class="p">(</span><span class="n">ltn</span><span class="o">.</span><span class="n">fuzzy_ops</span><span class="o">.</span><span class="n">ImpliesReichenbach</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Implies</span><span class="p">)</span>
<span class="go">Connective(connective_op=ImpliesReichenbach(stable=True))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Predicate</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Sigmoid</span><span class="p">()(</span>
<span class="gp">... </span>                                    <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">... </span>                                 <span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mf">0.56</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.9</span><span class="p">]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mf">0.7</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">tensor([0.6365, 0.7109])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">tensor([0.6682, 0.5498, 0.5250])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Implies</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">p</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">tensor([[0.7888, 0.7134, 0.6976],</span>
<span class="go">        [0.7640, 0.6799, 0.6622]])</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="ltn.fuzzy_ops.ImpliesReichenbach.__call__">
<span class="sig-name descname"><span class="pre">__call__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ltn.fuzzy_ops.ImpliesReichenbach.__call__" title="Permalink to this definition"></a></dt>
<dd><p>It applies the Reichenbach fuzzy implication operator to the given operands.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>x</strong><span class="classifier"><a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a></span></dt><dd><p>First operand on which the operator has to be applied.</p>
</dd>
<dt><strong>y</strong><span class="classifier"><a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a></span></dt><dd><p>Second operand on which the operator has to be applied.</p>
</dd>
<dt><strong>stable: :obj:`bool`, default=None</strong></dt><dd><p>Flag indicating whether to use the <a class="reference external" href="https://docs.python.org/3/c-api/stable.html#stable" title="(in Python v3.12)"><span class="xref std std-ref">stable version</span></a> of the operator or not.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a></dt><dd><p>The Reichenbach fuzzy implication of the two operands.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="field-list">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl>
<dt><strong>stable</strong><span class="classifier"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code></a></span></dt><dd><p>See <cite>stable</cite> parameter.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ltn.fuzzy_ops.ImpliesGoguen">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ltn.fuzzy_ops.</span></span><span class="sig-name descname"><span class="pre">ImpliesGoguen</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ltn.fuzzy_ops.ImpliesGoguen" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#ltn.fuzzy_ops.BinaryConnectiveOperator" title="ltn.fuzzy_ops.BinaryConnectiveOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">ltn.fuzzy_ops.BinaryConnectiveOperator</span></code></a></p>
<p>Goguen fuzzy implication operator.</p>
<p><span class="math notranslate nohighlight">\(\rightarrow_{Goguen}(x, y) = \left\{\begin{array}{ c l }1 &amp; \quad \textrm{if } x \le y \\ \frac{y}{x} &amp; \quad \textrm{otherwise} \end{array} \right.\)</span></p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>stable</strong><span class="classifier"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code></a>, default=True</span></dt><dd><p>Flag indicating whether to use the <a class="reference external" href="https://docs.python.org/3/c-api/stable.html#stable" title="(in Python v3.12)"><span class="xref std std-ref">stable version</span></a> of the operator or not.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The Goguen fuzzy implication could have vanishing gradients if not used in its <a class="reference external" href="https://docs.python.org/3/c-api/stable.html#stable" title="(in Python v3.12)"><span class="xref std std-ref">stable</span></a> version.</p>
<p class="rubric">Examples</p>
<p>Note that:</p>
<ul class="simple">
<li><p>variable <cite>x</cite> has two individuals;</p></li>
<li><p>variable <cite>y</cite> has three individuals;</p></li>
<li><p>the shape of the result of the conjunction is <cite>(2, 3)</cite> due to the <a class="reference internal" href="broadcasting.html#broadcasting"><span class="std std-ref">LTN broadcasting</span></a>. The first dimension is dedicated two variable <cite>x</cite>, while the second dimension to variable <cite>y</cite>;</p></li>
<li><p>at index <cite>(0, 0)</cite> there is the evaluation of the formula on first individual of <cite>x</cite> and first individual of <cite>y</cite>, at index <cite>(0, 1)</cite> there is the evaluation of the formula on first individual of <cite>x</cite> and second individual of <cite>y</cite>, and so forth.</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ltn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Implies</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Connective</span><span class="p">(</span><span class="n">ltn</span><span class="o">.</span><span class="n">fuzzy_ops</span><span class="o">.</span><span class="n">ImpliesGoguen</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Implies</span><span class="p">)</span>
<span class="go">Connective(connective_op=ImpliesGoguen(stable=True))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Predicate</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Sigmoid</span><span class="p">()(</span>
<span class="gp">... </span>                                    <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">... </span>                                 <span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mf">0.56</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.9</span><span class="p">]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mf">0.7</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">tensor([0.6365, 0.7109])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">tensor([0.6682, 0.5498, 0.5250])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Implies</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">p</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">tensor([[1.0000, 0.8639, 0.8248],</span>
<span class="go">        [0.9398, 0.7733, 0.7384]])</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="ltn.fuzzy_ops.ImpliesGoguen.__call__">
<span class="sig-name descname"><span class="pre">__call__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ltn.fuzzy_ops.ImpliesGoguen.__call__" title="Permalink to this definition"></a></dt>
<dd><p>It applies the Goguen fuzzy implication operator to the given operands.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>x</strong><span class="classifier"><a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a></span></dt><dd><p>First operand on which the operator has to be applied.</p>
</dd>
<dt><strong>y</strong><span class="classifier"><a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a></span></dt><dd><p>Second operand on which the operator has to be applied.</p>
</dd>
<dt><strong>stable</strong><span class="classifier"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code></a>, default=None</span></dt><dd><p>Flag indicating whether to use the <a class="reference external" href="https://docs.python.org/3/c-api/stable.html#stable" title="(in Python v3.12)"><span class="xref std std-ref">stable version</span></a> of the operator or not.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a></dt><dd><p>The Goguen fuzzy implication of the two operands.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="field-list">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl>
<dt><strong>stable</strong><span class="classifier"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code></a></span></dt><dd><p>See <cite>stable</cite> parameter.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ltn.fuzzy_ops.Equiv">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ltn.fuzzy_ops.</span></span><span class="sig-name descname"><span class="pre">Equiv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">and_op</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">implies_op</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ltn.fuzzy_ops.Equiv" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#ltn.fuzzy_ops.BinaryConnectiveOperator" title="ltn.fuzzy_ops.BinaryConnectiveOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">ltn.fuzzy_ops.BinaryConnectiveOperator</span></code></a></p>
<p>Equivalence (<span class="math notranslate nohighlight">\(\leftrightarrow\)</span>) fuzzy operator.</p>
<p><span class="math notranslate nohighlight">\(x \leftrightarrow y \equiv x \rightarrow y \land y \rightarrow x\)</span></p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>and_op</strong><span class="classifier"><a class="reference internal" href="#ltn.fuzzy_ops.BinaryConnectiveOperator" title="ltn.fuzzy_ops.BinaryConnectiveOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">ltn.fuzzy_ops.BinaryConnectiveOperator</span></code></a></span></dt><dd><p>Fuzzy conjunction operator to use for the equivalence operator.</p>
</dd>
<dt><strong>implies_op</strong><span class="classifier"><a class="reference internal" href="#ltn.fuzzy_ops.BinaryConnectiveOperator" title="ltn.fuzzy_ops.BinaryConnectiveOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">ltn.fuzzy_ops.BinaryConnectiveOperator</span></code></a></span></dt><dd><p>Fuzzy implication operator to use for the implication operator.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>the equivalence operator (<span class="math notranslate nohighlight">\(\leftrightarrow\)</span>) is implemented in LTNtorch as an operator which computes: <span class="math notranslate nohighlight">\(x \rightarrow y \land y \rightarrow x\)</span>;</p></li>
<li><p>the <cite>and_op</cite> parameter defines the operator for <span class="math notranslate nohighlight">\(\land\)</span>;</p></li>
<li><p>the <cite>implies_op</cite> parameter defines the operator for <span class="math notranslate nohighlight">\(\rightarrow\)</span>.</p></li>
</ul>
<p class="rubric">Examples</p>
<p>Note that:</p>
<ul class="simple">
<li><p>we have selected <a class="reference internal" href="#ltn.fuzzy_ops.AndProd" title="ltn.fuzzy_ops.AndProd"><code class="xref py py-class docutils literal notranslate"><span class="pre">ltn.fuzzy_ops.AndProd()</span></code></a> as an operator for the conjunction of the equivalence, and <a class="reference internal" href="#ltn.fuzzy_ops.ImpliesReichenbach" title="ltn.fuzzy_ops.ImpliesReichenbach"><code class="xref py py-class docutils literal notranslate"><span class="pre">ltn.fuzzy_ops.ImpliesReichenbach</span></code></a> as an operator for the implication;</p></li>
<li><p>variable <cite>x</cite> has two individuals;</p></li>
<li><p>variable <cite>y</cite> has three individuals;</p></li>
<li><p>the shape of the result of the conjunction is <cite>(2, 3)</cite> due to the <a class="reference internal" href="broadcasting.html#broadcasting"><span class="std std-ref">LTN broadcasting</span></a>. The first dimension is dedicated two variable <cite>x</cite>, while the second dimension to variable <cite>y</cite>;</p></li>
<li><p>at index <cite>(0, 0)</cite> there is the evaluation of the formula on first individual of <cite>x</cite> and first individual of <cite>y</cite>, at index <cite>(0, 1)</cite> there is the evaluation of the formula on first individual of <cite>x</cite> and second individual of <cite>y</cite>, and so forth.</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ltn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Equiv</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Connective</span><span class="p">(</span><span class="n">ltn</span><span class="o">.</span><span class="n">fuzzy_ops</span><span class="o">.</span><span class="n">Equiv</span><span class="p">(</span>
<span class="gp">... </span>                            <span class="n">and_op</span><span class="o">=</span><span class="n">ltn</span><span class="o">.</span><span class="n">fuzzy_ops</span><span class="o">.</span><span class="n">AndProd</span><span class="p">(),</span>
<span class="gp">... </span>                            <span class="n">implies_op</span><span class="o">=</span><span class="n">ltn</span><span class="o">.</span><span class="n">fuzzy_ops</span><span class="o">.</span><span class="n">ImpliesReichenbach</span><span class="p">()</span>
<span class="gp">... </span>                        <span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Equiv</span><span class="p">)</span>
<span class="go">Connective(connective_op=Equiv(and_op=AndProd(stable=True), implies_op=ImpliesReichenbach(stable=True)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Predicate</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Sigmoid</span><span class="p">()(</span>
<span class="gp">... </span>                                    <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">... </span>                                 <span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mf">0.56</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.9</span><span class="p">]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mf">0.7</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">tensor([0.6365, 0.7109])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">tensor([0.6682, 0.5498, 0.5250])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Equiv</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">p</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">tensor([[0.5972, 0.5708, 0.5645],</span>
<span class="go">        [0.6165, 0.5718, 0.5617]])</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="ltn.fuzzy_ops.Equiv.__call__">
<span class="sig-name descname"><span class="pre">__call__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ltn.fuzzy_ops.Equiv.__call__" title="Permalink to this definition"></a></dt>
<dd><p>It applies the fuzzy equivalence operator to the given operands.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>x</strong><span class="classifier"><a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a></span></dt><dd><p>First operand on which the operator has to be applied.</p>
</dd>
<dt><strong>y</strong><span class="classifier"><a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a></span></dt><dd><p>Second operand on which the operator has to be applied.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a></dt><dd><p>The fuzzy equivalence of the two operands.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>and_op: :class:`ltn.fuzzy_ops.BinaryConnectiveOperator`</strong></dt><dd><p>See <cite>and_op</cite> parameter.</p>
</dd>
<dt><strong>implies_op: :class:`ltn.fuzzy_ops.BinaryConnectiveOperator`</strong></dt><dd><p>See <cite>implies_op</cite> parameter.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ltn.fuzzy_ops.AggregationOperator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ltn.fuzzy_ops.</span></span><span class="sig-name descname"><span class="pre">AggregationOperator</span></span><a class="headerlink" href="#ltn.fuzzy_ops.AggregationOperator" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Abstract class for aggregation operators.</p>
<p>Every aggregation operator implemented in LTNtorch must inherit from this class
and implement the <cite>__call__()</cite> method.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#NotImplementedError" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a></dt><dd><p>Raised when <cite>__call__()</cite> is not implemented in the sub-class.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ltn.fuzzy_ops.AggregMin">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ltn.fuzzy_ops.</span></span><span class="sig-name descname"><span class="pre">AggregMin</span></span><a class="headerlink" href="#ltn.fuzzy_ops.AggregMin" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#ltn.fuzzy_ops.AggregationOperator" title="ltn.fuzzy_ops.AggregationOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">ltn.fuzzy_ops.AggregationOperator</span></code></a></p>
<p>Min fuzzy aggregation operator.</p>
<p><span class="math notranslate nohighlight">\(A_{T_{M}}(x_1, \dots, x_n) = \operatorname{min}(x_1, \dots, x_n)\)</span></p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ltn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Forall</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Quantifier</span><span class="p">(</span><span class="n">ltn</span><span class="o">.</span><span class="n">fuzzy_ops</span><span class="o">.</span><span class="n">AggregMin</span><span class="p">(),</span> <span class="n">quantifier</span><span class="o">=</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Forall</span><span class="p">)</span>
<span class="go">Quantifier(agg_op=AggregMin(), quantifier=&#39;f&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Predicate</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Sigmoid</span><span class="p">()(</span>
<span class="gp">... </span>                                    <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">... </span>                                 <span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mf">0.56</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.9</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.7</span><span class="p">]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">tensor([0.6365, 0.7109, 0.6682])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Forall</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">tensor(0.6365)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="ltn.fuzzy_ops.AggregMin.__call__">
<span class="sig-name descname"><span class="pre">__call__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keepdim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ltn.fuzzy_ops.AggregMin.__call__" title="Permalink to this definition"></a></dt>
<dd><p>It applies the min fuzzy aggregation operator to the given formula’s <a class="reference internal" href="grounding.html#notegrounding"><span class="std std-ref">grounding</span></a> on
the selected dimensions.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>xs</strong><span class="classifier"><a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a></span></dt><dd><p><a class="reference internal" href="grounding.html#notegrounding"><span class="std std-ref">Grounding</span></a> of formula on which the aggregation has to be performed.</p>
</dd>
<dt><strong>dim</strong><span class="classifier"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.12)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code></a>, default=None</span></dt><dd><p>Tuple containing the indexes of dimensions on which the aggregation has to be performed.</p>
</dd>
<dt><strong>keepdim</strong><span class="classifier"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code></a>, default=False</span></dt><dd><p>Flag indicating whether the output has to keep the same dimensions as the input after
the aggregation.</p>
</dd>
<dt><strong>mask</strong><span class="classifier"><a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a>, default=None</span></dt><dd><p>Boolean mask for excluding values of ‘xs’ from the aggregation. It is internally used for guarded
quantification. The mask must have the same shape of ‘xs’. <cite>False</cite> means exclusion, <cite>True</cite> means inclusion.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a></dt><dd><p>Min fuzzy aggregation of the formula.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ValueError</span></code></a></dt><dd><p>Raises when the <a class="reference internal" href="grounding.html#notegrounding"><span class="std std-ref">grounding</span></a> of the formula (‘xs’) and the mask do not have the same
shape.
Raises when the ‘mask’ is not boolean.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ltn.fuzzy_ops.AggregMean">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ltn.fuzzy_ops.</span></span><span class="sig-name descname"><span class="pre">AggregMean</span></span><a class="headerlink" href="#ltn.fuzzy_ops.AggregMean" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#ltn.fuzzy_ops.AggregationOperator" title="ltn.fuzzy_ops.AggregationOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">ltn.fuzzy_ops.AggregationOperator</span></code></a></p>
<p>Mean fuzzy aggregation operator.</p>
<p><span class="math notranslate nohighlight">\(A_{M}(x_1, \dots, x_n) = \frac{1}{n} \sum_{i = 1}^n x_i\)</span></p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ltn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Forall</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Quantifier</span><span class="p">(</span><span class="n">ltn</span><span class="o">.</span><span class="n">fuzzy_ops</span><span class="o">.</span><span class="n">AggregMean</span><span class="p">(),</span> <span class="n">quantifier</span><span class="o">=</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Forall</span><span class="p">)</span>
<span class="go">Quantifier(agg_op=AggregMean(), quantifier=&#39;f&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Predicate</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Sigmoid</span><span class="p">()(</span>
<span class="gp">... </span>                                    <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">... </span>                                 <span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mf">0.56</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.9</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.7</span><span class="p">]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">tensor([0.6365, 0.7109, 0.6682])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Forall</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">tensor(0.6719)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="ltn.fuzzy_ops.AggregMean.__call__">
<span class="sig-name descname"><span class="pre">__call__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keepdim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ltn.fuzzy_ops.AggregMean.__call__" title="Permalink to this definition"></a></dt>
<dd><p>It applies the mean fuzzy aggregation operator to the given formula’s <a class="reference internal" href="grounding.html#notegrounding"><span class="std std-ref">grounding</span></a> on
the selected dimensions.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>xs</strong><span class="classifier"><a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a></span></dt><dd><p><a class="reference internal" href="grounding.html#notegrounding"><span class="std std-ref">Grounding</span></a> of formula on which the aggregation has to be performed.</p>
</dd>
<dt><strong>dim</strong><span class="classifier"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.12)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code></a>, default=None</span></dt><dd><p>Tuple containing the indexes of dimensions on which the aggregation has to be performed.</p>
</dd>
<dt><strong>keepdim</strong><span class="classifier"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code></a>, default=False</span></dt><dd><p>Flag indicating whether the output has to keep the same dimensions as the input after
the aggregation.</p>
</dd>
<dt><strong>mask</strong><span class="classifier"><a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a>, default=None</span></dt><dd><p>Boolean mask for excluding values of ‘xs’ from the aggregation. It is internally used for guarded
quantification. The mask must have the same shape of ‘xs’. <cite>False</cite> means exclusion, <cite>True</cite> means inclusion.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a></dt><dd><p>Mean fuzzy aggregation of the formula.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ValueError</span></code></a></dt><dd><p>Raises when the <a class="reference internal" href="grounding.html#notegrounding"><span class="std std-ref">grounding</span></a> of the formula (‘xs’) and the mask do not have the same
shape.
Raises when the ‘mask’ is not boolean.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ltn.fuzzy_ops.AggregPMean">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ltn.fuzzy_ops.</span></span><span class="sig-name descname"><span class="pre">AggregPMean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ltn.fuzzy_ops.AggregPMean" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#ltn.fuzzy_ops.AggregationOperator" title="ltn.fuzzy_ops.AggregationOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">ltn.fuzzy_ops.AggregationOperator</span></code></a></p>
<p><cite>pMean</cite> fuzzy aggregation operator.</p>
<p><span class="math notranslate nohighlight">\(A_{pM}(x_1, \dots, x_n) = (\frac{1}{n} \sum_{i = 1}^n x_i^p)^{\frac{1}{p}}\)</span></p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>p</strong><span class="classifier"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code></a>, default=2</span></dt><dd><p>Value of hyper-parameter <cite>p</cite> of the <cite>pMean</cite> fuzzy aggregation operator.</p>
</dd>
<dt><strong>stable</strong><span class="classifier"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code></a>, default=True</span></dt><dd><p>Flag indicating whether to use the <a class="reference external" href="https://docs.python.org/3/c-api/stable.html#stable" title="(in Python v3.12)"><span class="xref std std-ref">stable version</span></a> of the operator or not.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The <cite>pMean</cite> aggregation operator has been selected as an approximation of
<span class="math notranslate nohighlight">\(\exists\)</span> with <span class="math notranslate nohighlight">\(p \geq 1\)</span>.
If <span class="math notranslate nohighlight">\(p \to \infty\)</span>, then the <cite>pMean</cite> operator tends to the
maximum of the input values (classical behavior of <span class="math notranslate nohighlight">\(\exists\)</span>).</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ltn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Exists</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Quantifier</span><span class="p">(</span><span class="n">ltn</span><span class="o">.</span><span class="n">fuzzy_ops</span><span class="o">.</span><span class="n">AggregPMean</span><span class="p">(),</span> <span class="n">quantifier</span><span class="o">=</span><span class="s1">&#39;e&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Exists</span><span class="p">)</span>
<span class="go">Quantifier(agg_op=AggregPMean(p=2, stable=True), quantifier=&#39;e&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Predicate</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Sigmoid</span><span class="p">()(</span>
<span class="gp">... </span>                                    <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">... </span>                                 <span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mf">0.56</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.9</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.7</span><span class="p">]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">tensor([0.6365, 0.7109, 0.6682])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Exists</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">tensor(0.6726)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="ltn.fuzzy_ops.AggregPMean.__call__">
<span class="sig-name descname"><span class="pre">__call__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keepdim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ltn.fuzzy_ops.AggregPMean.__call__" title="Permalink to this definition"></a></dt>
<dd><p>It applies the <cite>pMean</cite> aggregation operator to the given formula’s <a class="reference internal" href="grounding.html#notegrounding"><span class="std std-ref">grounding</span></a>
on the selected dimensions.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>xs</strong><span class="classifier"><a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a></span></dt><dd><p><a class="reference internal" href="grounding.html#notegrounding"><span class="std std-ref">Grounding</span></a> of formula on which the aggregation has to be performed.</p>
</dd>
<dt><strong>dim</strong><span class="classifier"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.12)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code></a>, default=None</span></dt><dd><p>Tuple containing the indexes of dimensions on which the aggregation has to be performed.</p>
</dd>
<dt><strong>keepdim</strong><span class="classifier"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code></a>, default=False</span></dt><dd><p>Flag indicating whether the output has to keep the same dimensions as the input after
the aggregation.</p>
</dd>
<dt><strong>mask</strong><span class="classifier"><a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a>, default=None</span></dt><dd><p>Boolean mask for excluding values of ‘xs’ from the aggregation. It is internally used for guarded
quantification. The mask must have the same shape of ‘xs’. <cite>False</cite> means exclusion, <cite>True</cite> means inclusion.</p>
</dd>
<dt><strong>p</strong><span class="classifier"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code></a>, default=None</span></dt><dd><p>Value of hyper-parameter <cite>p</cite> of the <cite>pMean</cite> fuzzy aggregation operator.</p>
</dd>
<dt><strong>stable</strong><span class="classifier"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code></a>, default=None</span></dt><dd><p>Flag indicating whether to use the <a class="reference external" href="https://docs.python.org/3/c-api/stable.html#stable" title="(in Python v3.12)"><span class="xref std std-ref">stable version</span></a> of the operator or not.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a></dt><dd><p><cite>pMean</cite> fuzzy aggregation of the formula.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ValueError</span></code></a></dt><dd><p>Raises when the <a class="reference internal" href="grounding.html#notegrounding"><span class="std std-ref">grounding</span></a> of the formula (‘xs’) and the mask do not have the same
shape.
Raises when the ‘mask’ is not boolean.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="field-list">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl>
<dt><strong>p</strong><span class="classifier"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code></a></span></dt><dd><p>See <cite>p</cite> parameter.</p>
</dd>
<dt><strong>stable</strong><span class="classifier"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code></a></span></dt><dd><p>See <cite>stable</cite> parameter.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ltn.fuzzy_ops.AggregPMeanError">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ltn.fuzzy_ops.</span></span><span class="sig-name descname"><span class="pre">AggregPMeanError</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ltn.fuzzy_ops.AggregPMeanError" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#ltn.fuzzy_ops.AggregationOperator" title="ltn.fuzzy_ops.AggregationOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">ltn.fuzzy_ops.AggregationOperator</span></code></a></p>
<p><cite>pMeanError</cite> fuzzy aggregation operator.</p>
<p><span class="math notranslate nohighlight">\(A_{pME}(x_1, \dots, x_n) = 1 - (\frac{1}{n} \sum_{i = 1}^n (1 - x_i)^p)^{\frac{1}{p}}\)</span></p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>p</strong><span class="classifier"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code></a>, default=2</span></dt><dd><p>Value of hyper-parameter <cite>p</cite> of the <cite>pMeanError</cite> fuzzy aggregation operator.</p>
</dd>
<dt><strong>stable</strong><span class="classifier"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code></a>, default=True</span></dt><dd><p>Flag indicating whether to use the <a class="reference external" href="https://docs.python.org/3/c-api/stable.html#stable" title="(in Python v3.12)"><span class="xref std std-ref">stable version</span></a> of the operator or not.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The <cite>pMeanError</cite> aggregation operator has been selected as an approximation of
<span class="math notranslate nohighlight">\(\forall\)</span> with <span class="math notranslate nohighlight">\(p \geq 1\)</span>. If <span class="math notranslate nohighlight">\(p \to \infty\)</span>, then the <cite>pMeanError</cite> operator tends to the
minimum of the input values (classical behavior of <span class="math notranslate nohighlight">\(\forall\)</span>).</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ltn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Forall</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Quantifier</span><span class="p">(</span><span class="n">ltn</span><span class="o">.</span><span class="n">fuzzy_ops</span><span class="o">.</span><span class="n">AggregPMeanError</span><span class="p">(),</span> <span class="n">quantifier</span><span class="o">=</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Forall</span><span class="p">)</span>
<span class="go">Quantifier(agg_op=AggregPMeanError(p=2, stable=True), quantifier=&#39;f&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Predicate</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Sigmoid</span><span class="p">()(</span>
<span class="gp">... </span>                                    <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">... </span>                                 <span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mf">0.56</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.9</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.7</span><span class="p">]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">tensor([0.6365, 0.7109, 0.6682])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Forall</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">tensor(0.6704)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="ltn.fuzzy_ops.AggregPMeanError.__call__">
<span class="sig-name descname"><span class="pre">__call__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keepdim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ltn.fuzzy_ops.AggregPMeanError.__call__" title="Permalink to this definition"></a></dt>
<dd><p>It applies the <cite>pMeanError</cite> aggregation operator to the given formula’s <a class="reference internal" href="grounding.html#notegrounding"><span class="std std-ref">grounding</span></a>
on the selected dimensions.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>xs</strong><span class="classifier"><a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a></span></dt><dd><p><a class="reference internal" href="grounding.html#notegrounding"><span class="std std-ref">Grounding</span></a> of formula on which the aggregation has to be performed.</p>
</dd>
<dt><strong>dim</strong><span class="classifier"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.12)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code></a>, default=None</span></dt><dd><p>Tuple containing the indexes of dimensions on which the aggregation has to be performed.</p>
</dd>
<dt><strong>keepdim</strong><span class="classifier"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code></a>, default=False</span></dt><dd><p>Flag indicating whether the output has to keep the same dimensions as the input after
the aggregation.</p>
</dd>
<dt><strong>mask</strong><span class="classifier"><a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a>, default=None</span></dt><dd><p>Boolean mask for excluding values of ‘xs’ from the aggregation. It is internally used for guarded
quantification. The mask must have the same shape of ‘xs’. <cite>False</cite> means exclusion, <cite>True</cite> means inclusion.</p>
</dd>
<dt><strong>p</strong><span class="classifier"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code></a>, default=None</span></dt><dd><p>Value of hyper-parameter <cite>p</cite> of the <cite>pMeanError</cite> fuzzy aggregation operator.</p>
</dd>
<dt><strong>stable: :obj:`bool`, default=None</strong></dt><dd><p>Flag indicating whether to use the <a class="reference external" href="https://docs.python.org/3/c-api/stable.html#stable" title="(in Python v3.12)"><span class="xref std std-ref">stable version</span></a> of the operator or not.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a></dt><dd><p><cite>pMeanError</cite> fuzzy aggregation of the formula.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ValueError</span></code></a></dt><dd><p>Raises when the <a class="reference internal" href="grounding.html#notegrounding"><span class="std std-ref">grounding</span></a> of the formula (‘xs’) and the mask do not have the same
shape.
Raises when the ‘mask’ is not boolean.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="field-list">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl>
<dt><strong>p</strong><span class="classifier"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code></a></span></dt><dd><p>See <cite>p</cite> parameter.</p>
</dd>
<dt><strong>stable</strong><span class="classifier"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code></a></span></dt><dd><p>See <cite>stable</cite> parameter.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ltn.fuzzy_ops.SatAgg">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ltn.fuzzy_ops.</span></span><span class="sig-name descname"><span class="pre">SatAgg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">agg_op</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">AggregPMeanError(p=2,</span> <span class="pre">stable=True)</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ltn.fuzzy_ops.SatAgg" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p><cite>SatAgg</cite> aggregation operator.</p>
<p><span class="math notranslate nohighlight">\(\operatorname{SatAgg}_{\phi \in \mathcal{K}} \mathcal{G}_{\theta} (\phi)\)</span></p>
<p>It aggregates the truth values of the closed formulas given in input, namely the formulas
<span class="math notranslate nohighlight">\(\phi_1, \dots, \phi_n\)</span> contained in the knowledge base <span class="math notranslate nohighlight">\(\mathcal{K}\)</span>. In the notation,
<span class="math notranslate nohighlight">\(\mathcal{G}_{\theta}\)</span> is the <a class="reference internal" href="grounding.html#notegrounding"><span class="std std-ref">grounding</span></a> function, parametrized by <span class="math notranslate nohighlight">\(\theta\)</span>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>agg_op</strong><span class="classifier"><a class="reference internal" href="#ltn.fuzzy_ops.AggregationOperator" title="ltn.fuzzy_ops.AggregationOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">ltn.fuzzy_ops.AggregationOperator</span></code></a>, default=AggregPMeanError(p=2)</span></dt><dd><p>Fuzzy aggregation operator used by the <cite>SatAgg</cite> operator to perform the aggregation.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><dl class="simple">
<dt><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#TypeError" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeError</span></code></a></dt><dd><p>Raises when the type of the input parameter is not correct.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p><cite>SatAgg</cite> is particularly useful for computing the overall satisfaction level of a knowledge base when <a class="reference internal" href="learningltn.html#notelearning"><span class="std std-ref">learning</span></a> a Logic Tensor Network;</p></li>
<li><p>the result of the <cite>SatAgg</cite> aggregation is a scalar. It is the satisfaction level of the knowledge based composed of the closed formulas given in input.</p></li>
</ul>
<p class="rubric">Examples</p>
<p><cite>SatAgg</cite> can be used to aggregate the truth values of formulas contained in a knowledge base. Note that:</p>
<ul class="simple">
<li><p><cite>SatAgg</cite> takes as input a tuple of <a class="reference internal" href="core.html#ltn.core.LTNObject" title="ltn.core.LTNObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">ltn.core.LTNObject</span></code></a> and/or <a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a>;</p></li>
<li><p>when some <a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a> are given to <cite>SatAgg</cite>, they have to be scalars in [0., 1.] since <cite>SatAgg</cite> is designed to work with closed formulas;</p></li>
<li><p>in this example, our knowledge base is composed of closed formulas <cite>f1</cite>, <cite>f2</cite>, and <cite>f3</cite>;</p></li>
<li><p><cite>SatAgg</cite> applies the <cite>pMeanError</cite> aggregation operator to the truth values of these formulas. The result is a new truth value which can be interpreted as a satisfaction level of the entire knowledge base;</p></li>
<li><p>the result of <cite>SatAgg</cite> is a <a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a> since it has been designed for learning in PyTorch. The idea is to put the result of the operator directly inside the loss function of the LTN. See this <a class="reference external" href="https://nbviewer.jupyter.org/github/bmxitalia/LTNtorch/blob/main/tutorials/3-knowledgebase-and-learning.ipynb">tutorial</a> for a detailed example.</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ltn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.03</span><span class="p">],</span>
<span class="gp">... </span>                                    <span class="p">[</span><span class="mf">2.3</span><span class="p">,</span> <span class="mf">4.3</span><span class="p">]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mf">3.4</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">],</span>
<span class="gp">... </span>                                    <span class="p">[</span><span class="mf">5.4</span><span class="p">,</span> <span class="mf">0.43</span><span class="p">]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Predicate</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Sigmoid</span><span class="p">()(</span>
<span class="gp">... </span>                                    <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">... </span>                                 <span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Predicate</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Sigmoid</span><span class="p">()(</span>
<span class="gp">... </span>                                        <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
<span class="gp">... </span>                                    <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Forall</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Quantifier</span><span class="p">(</span><span class="n">ltn</span><span class="o">.</span><span class="n">fuzzy_ops</span><span class="o">.</span><span class="n">AggregPMeanError</span><span class="p">(),</span> <span class="n">quantifier</span><span class="o">=</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">And</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Connective</span><span class="p">(</span><span class="n">ltn</span><span class="o">.</span><span class="n">fuzzy_ops</span><span class="o">.</span><span class="n">AndProd</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Forall</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">Forall</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="n">q</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f3</span> <span class="o">=</span> <span class="n">And</span><span class="p">(</span><span class="n">Forall</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="n">q</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)),</span> <span class="n">Forall</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sat_agg</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">fuzzy_ops</span><span class="o">.</span><span class="n">SatAgg</span><span class="p">(</span><span class="n">ltn</span><span class="o">.</span><span class="n">fuzzy_ops</span><span class="o">.</span><span class="n">AggregPMeanError</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sat_agg</span><span class="p">)</span>
<span class="go">SatAgg(agg_op=AggregPMeanError(p=2, stable=True))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">sat_agg</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">f3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">out</span><span class="p">))</span>
<span class="go">&lt;class &#39;torch.Tensor&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
<span class="go">tensor(0.7294)</span>
</pre></div>
</div>
<p>In the previous example, some closed formulas (<a class="reference internal" href="core.html#ltn.core.LTNObject" title="ltn.core.LTNObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">ltn.core.LTNObject</span></code></a>) have been given to the <cite>SatAgg</cite>
operator.
In this example, we show that <cite>SatAgg</cite> can take as input also <a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a> containing the result of some
closed formulas, namely scalars in [0., 1.]. Note that:</p>
<ul class="simple">
<li><p><cite>f2</cite> is just a <a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a>;</p></li>
<li><p>since <cite>f2</cite> contains a scalar in [0., 1.], its value can be interpreted as a truth value of a closed formula. For this reason, it is possible to give <cite>f2</cite> to the <cite>SatAgg</cite> operator to get the aggregation of <cite>f1</cite> (<a class="reference internal" href="core.html#ltn.core.LTNObject" title="ltn.core.LTNObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">ltn.core.LTNObject</span></code></a>) and <cite>f2</cite> (<a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a>).</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.03</span><span class="p">],</span>
<span class="gp">... </span>                                    <span class="p">[</span><span class="mf">2.3</span><span class="p">,</span> <span class="mf">4.3</span><span class="p">]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Predicate</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Sigmoid</span><span class="p">()(</span>
<span class="gp">... </span>                                    <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">... </span>                                 <span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Forall</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">Quantifier</span><span class="p">(</span><span class="n">ltn</span><span class="o">.</span><span class="n">fuzzy_ops</span><span class="o">.</span><span class="n">AggregPMeanError</span><span class="p">(),</span> <span class="n">quantifier</span><span class="o">=</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Forall</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="mf">0.7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sat_agg</span> <span class="o">=</span> <span class="n">ltn</span><span class="o">.</span><span class="n">fuzzy_ops</span><span class="o">.</span><span class="n">SatAgg</span><span class="p">(</span><span class="n">ltn</span><span class="o">.</span><span class="n">fuzzy_ops</span><span class="o">.</span><span class="n">AggregPMeanError</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sat_agg</span><span class="p">)</span>
<span class="go">SatAgg(agg_op=AggregPMeanError(p=2, stable=True))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">sat_agg</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">out</span><span class="p">))</span>
<span class="go">&lt;class &#39;torch.Tensor&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
<span class="go">tensor(0.6842)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="ltn.fuzzy_ops.SatAgg.__call__">
<span class="sig-name descname"><span class="pre">__call__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">closed_formulas</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ltn.fuzzy_ops.SatAgg.__call__" title="Permalink to this definition"></a></dt>
<dd><p>It applies the <cite>SatAgg</cite> aggregation operator to the given closed formula’s <a class="reference internal" href="grounding.html#notegrounding"><span class="std std-ref">groundings</span></a>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>closed_formulas</strong><span class="classifier"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.12)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="core.html#ltn.core.LTNObject" title="ltn.core.LTNObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">ltn.core.LTNObject</span></code></a> and/or <a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a></span></dt><dd><p>Tuple of closed formulas (<cite>LTNObject</cite> and/or tensors) for which the aggregation has to be computed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a></dt><dd><p>The result of the <cite>SatAgg</cite> aggregation.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#TypeError" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeError</span></code></a></dt><dd><p>Raises when the type of the input parameter is not correct.</p>
</dd>
<dt><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ValueError</span></code></a></dt><dd><p>Raises when the truth values of the formulas/tensors given in input are not in the range [0., 1.].
Raises when the truth values of the formulas/tensors given in input are not scalars, namely some formulas
are not closed formulas.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="field-list">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl>
<dt><strong>agg_op</strong><span class="classifier"><a class="reference internal" href="#ltn.fuzzy_ops.AggregationOperator" title="ltn.fuzzy_ops.AggregationOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">ltn.fuzzy_ops.AggregationOperator</span></code></a>, default=AggregPMeanError(p=2)</span></dt><dd><p>See <cite>agg_op</cite> parameter.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="core.html" class="btn btn-neutral float-left" title="ltn.core" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Tommaso Carraro.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>